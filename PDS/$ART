Managing Code Changes
By Joseph Caughman

FUSION Overview

Change management is an important aspect of any Information System
environment, as it is necessary to provide a method of migrating test
code to the production system and a method of applying third-party
vendor code to the production system.  Many test systems involve
concurrent development, meaning that more than one programmer may have
code applied to a test program.  When a programmer needs to apply the
code to the production system, he or she will have to 'cut and paste'
the code to production.  The 'cut and paste' method can be complicated
and time-consuming if many lines of code are involved or if many modules
need to be updated.  Commercial code migration systems are available to
assist in migrating code.   But due to cost constraints of purchasing
such a system, I developed the FUSION code management system that
provides the basis for managing the migration of complicated coding
changes.

FUSION takes advantage of the existing components of the MVS system,
mainly REXX/ISPF and the SUPERC comparison utility.  SUPERC is an
accurate comparison tool that summarizes program comparisons in terms of
code inserts and deletes.  FUSION, therefore, is a post-processor that
utilizes this information to rebuild the updated file.  The result is a
versatile code migration tool that eliminates much of the time
ordinarily spent 'cutting and pasting' code fro m one module version to
another, and provides a two-tier comparison routine to allow the
programmer to verify the results of the compare.


How It Works

FUSION initiates a comparison between the UPDATED copy and the BASE copy
of a program.  UPDATED is the copy with the coding changes, and BASE is
the unmodified copy.   For COBOL programs, it is assumed that new lines
of code are identified with a fix identifier in columns 1-6.  It is also
assumed that deleted, or obsolete, lines are commented out with the fix
identifier in columns 1-6.  The merge results will be placed in the
DESTINATION library.  The compare is performed using the UPDLDEL option
of SUPERC, which provides a SUPERC update file that lists the inserts,
deletions and replacements.  The resulting list file contains all of the
information needed to rebuild the BASE copy with the selected updates
fro m the UPDATED copy.  Based on the program logic, FUSION looks for
any inserts, deletes or replacements that correspond to the fix
identifier of the code to be moved.  The inserts and replacements are
organized into code blocks, with each block marked accordingly.  FUSION
buffers each code block into the main stem variable called OUTREC.
Lines of code that are not different between UPDATED and BASE are stored
in the first level of the stem variable.  This includes lines that are
marked as old replacement.  The structure of OUTREC is as follows.
There are three stem levels used in OUTREC.  The first level is numeric
and holds the corresponding Match, absolute Insert and absolute Delete
lines.  Only absolute insert lines that have the fix identifier will be
inserted.  All absolute delete lines are reinserted in the first level.
Insert Replace, or I-RP, lines are inserted into the second stem level,
which uses a numeric stem.  The Delete Replace, or D-RP, lines are
sequentially compressed and matched against the inserted lines in the
second-level stem.  These lines are also compressed.  If an exact match
occurs, the I-RP line is discarded.  If no match occurs, that line is
reinsert ed into the third-level stem at the same relative offset in the
second-level stem where the mismatch occurred.   See figure 1.

The unspool process will read the following sequence:  OUTREC.1,
OUTREC.2, OUTREC.2.1, OUTREC.2.2, OUTREC.2.2.1 , OUTREC.3.

There are six control commands that are generated by the SUPERC process
that are of interest to the FUSION process.  They are  I-, for Insert,
D-, for Delete, M-, for Merge, I-RP, for Insert Replace, D-RP,  for
Delete Replace, and D-RF, for Delete Reformat.   The commands are
followed by the corresponding text that relates to the function.

To elaborate on the SUPERC comparis on process and the FUSION stem
structure, consider the compare sample below.   The control lines have
been truncated for this illustration to make it easier to understand.
The SI, or fix number, of interest is WB8485.   The lines that are
marked with M- indicate a match between the new and old source.  In
other words, these lines are similar between the two source members.
These lines are stored in the first stem level of OUTREC.  The line that
is marked with I- is stored in the first stem level of OUTREC.  If the
SI number was not equal to WB8485, then the line would be discarded.
This allows only the desired lines to be inserted into the rebuilt file.
The lines that are marked with I-RP show lines that were inserted into
the updated copy.  The corresponding D-RP shows the line that was
deleted from the updated copy.  The inserted lines are stored in the
second-level stem of OUTREC.  The lines are stored whether or not they
contain the desi red fix identifier.  If a line contains the fix
identifier, then that line is marked as active in the stem variable.
The block variable is also set to active.  For the deleted, or D-RP,
lines, each line is compressed and compared to each compressed line on
the insert stem.  The compression process omits the fix identifier part
of the line, as it is not part of the desired comparison process.  The
deleted, D-RP, line below found an exact match for the insert block.
So, the deleted line is discarded.  If a match was not found for the
deleted line, it will be reinserted into the stem variable on the level
three stem.   If no active line was found in the I-RP block, then the
block is discarded and the subsequent D-RP block is written to the first
level stem of OUTREC.  All D-, or absolute deletes, are always
reinserted into the main stem of OUTREC.

Any inserts are stored in the second stem level of OUTREC.  See
figure 2.

For this example, let us assume that the stem starts at 1.  So, the
stem variable looks like that shown in figure 3.

After the stem variable has been built for the updated program, the last
step is to 'unspool' the variable into a single-level stem variable,
suitable for the EXECIO write function.  This unspooling process scans
the first level of the variable and any underlying second and third
level stems.  Any second-level stem that is marked as active is spooled
out to the output variable.


Screen Interface Overview

BASE DSN is the data set containing production source.

UPDATED DSN is the data set containing the third-party vendor software
or the data set that holds tested changes.

DESTINATION DSN is the data set that will hold the result of the FUSION
operation.

MODULE NAME is the name of the module to be updated.  If the name of the
BASE and UPDATED modules are different, then the name of the BASE module
and UPDATED module can be specified in MODULE NAME, separated by a
space.  The DESTINATION module name is then referred to by the BASE
module name.  An alternate DESTINATION name can be specified by adding a
third name to the MODULE NAME.

APPLICATION FUNCTION specifies the type of merge operation to be
performed.  Normally, it is MIGRATE.  There are four migration options
available which control how code is moved from one program version to
another.  They are MIGRATE, MOVE, MASSMIG and MANSEL.  They are user
selected in the APPLICATION FUNCTION field of the main FUSION screen.
See figure 4.

MIGRATE is used when third-party vendor software needs to be applied to
the base system or when a program fix involving concurrent development
needs to be moved to production.   When code is applied to a module, the
code should always be identified by a fix identifier in columns 1-6 of a
COBOL program and the first and last fields of an Assembler program.
Obsolete code should be commented out and identified with the fix
identifier in columns 1-6 of the COBOL module.  This provides FUSION a
reference when updating the DESTINATION.

MOVE will migrate program code without performing associated deletes on
obsolete code.  This is a true 'cut and paste' operation.  The
programmer is responsible for deleting the code.  This mode is useful
when migrating code to a highly modified member.

MASSMIG will merge all code changes from the old source to the new
source.  The function is similar to MOVE, except that all code found in
the old version will be moved to the new version.  This is useful when
a customer needs to update their base system to the latest release of
the vendor system.  Once again, the user is responsible for performing
the associated deletes on obsolete code.

MANSEL allows user-selected migration of code from one program version
to another.  The UPDATED copy is edited in an 82-byte format, allowing
the user to select lines of code by entering an S in the first column.
This is useful when only a portion of a program needs to be updated or
if the desired code is not identified by a fix identifier.

There are 5 PROCESS OPTIONS that control how FUSION handles the merge
results.  They are DISPLAY, COMPAREA, COMPAREB, PCOMPAREA, and
NORMALIZE. The commands can be entered in PROCESS OPTIONS in any order.

DISPLAY--Displays the DESTINATION module with the merge results.  It is
recommended that this feature always be set.

COMPAREA--Performs a comparison between the updated DESTINATION source
and the BASE source and displays the results.   It is recommended that
this feature always be set.

COMPAREB--Performs a comparison between the updated DESTINATION source
and the UPDATED source.  The results of the compare are displayed.  This
feature is useful to verify if all selected lines of code were merged
into the DESTINATION source.  Ideally, the selected lines should not
appear in this comparison.

PCOMPAREA--Prints the results of the COMPAREA comparison.

NORMALIZE--Normalizes numeric data when at tempting to update a highly
modified source member.  This helps to prevent merge problems that may
occur in Working Storage.  This option should normally not be used.

FUSION automatically determines the language of the program being
updated.  The current supported languages are COBOL and Assembler
formats.  The Assembler formats include macro and command level,
including online maps.

For result integrity, a two-level comparison process is performed after
a FUSION merge request, if it is requested by the COMPAREA command.
This compares the DESTINATION, or updated program, to the BASE source
program.  This allows inspection of the compare process to ensure that
the lines of code were applied correctly.


Technical Considerations

Considering that program updates are identified by a fix identifier in
columns 1-6 of a COBOL program and the rightmost field of an Assembler
program, FUSION can selectively migrate code by this identifier.  If the
number is inaccurate or missing then FUSION will not be able to apply
that line of code.  The MANSEL option will allow the programmer to
manually select the desired lines of code if the documentation is
inaccurate or missing.  The effectiveness of FUSION depends in a large
part on the accuracy of the documentation of the changes.  Since FUSION
is not a code analyzer, it is up to the programmer to resolve conflicts
and collisions.  But, there is a high probability that the code will be
merged correctly.  The comparison between the production and DESTINATION
version of the module allows the programmer to verify the merge results.
Another consideration is with code dependencies.  Before applying a
program fix, it is necessary to determine if there are other program
fixes that it is dependent on.


Installation Guide

FUSION is available on the CBT tape.  It is file 644 and can be
referenced with the following URL:

ftp://ftp.cbttape.org/pub/cbt/CBT644.zip

Once the Zip file is downloaded, unzip it to a known PC directory.  To
upload the XMI file to the mainframe, first use =6 on the TSO command
line to go to the TSO Command Shell screen.  Then select the ACTIONS tab
of the session and select SEND FILE TO HOST.   This is assuming that you
are using a Windows 3270 emulator.  Other emulators may differ from
the one used in my environment.  Enter the PC FILE name that holds the
unzipped XMI file, such as

\\wbmpfil01\data$\jfcaugh\download\cbt644.xmi.

This was the data set used when I downloaded file 644.  Click on ADD TO
LIST to add the request to the transfer list.  Under OPTIONS, select
the MVS/TSO tab.  Select TRANSFER TYPE as Binary, RECORD FORMAT as
Fixed, and enter 80 as LOGICAL RECORD LENGTH.  This format is needed to
unload an XMI file.  Enter 1 for primary cylinder allocation and 1 for
secondary cylinder allocation.  Click on SAVE to save the new binary
protocol.  Click on OK to return to the transfer panel.  Click on SEND
to start the transfer.  This creates a TSO data set that uses your TSO
account id as the high level qualifier followed by CBT644.XMIBIN.  For
example, it is MYUSRID.CBT644.XMIBIN .

Next use the TSO RECEIVE command to create the FUSION files.  The
command is as follows:  RECEIVE INDS('dataset') where 'dataset' is the
name of the sequential file, such as:
RECEIVE INDS('MYUSRID.CBT644.XMIBIN').   This will create a partitioned
data set named MYUSRID.CBT462.FILE644.PDS.   The high level qualifier
depends on the TSO account id.  If there is any question about the data
set name, check it when running the RECEIVE command.  It appears in a
text screen as 'Data set CBT.CBT462.FILE644.PDS from CSSJK on JES2MVS'.
The CBT qualifier will be replaced with your TSO account id.  The
installation JCL is called $PDSLOAD.  Edit the JCL.  Change the account
information to your shop standards.  Change all occurrences of USERID to
your primary TSO user account id.  USERID will be in lower case.  Your
account id must be in upper case.  The SYSUT2 file allocations begin
with FUSION.  It is important to have RACF allow the allocation to
occur.  If other names must be used, then be sure that the LIBDEF
references in the CNTL file are changed, too.  Also, change the REGDSN
line in the Fusion exec to point to the data set name used for the CNTL
file.  This should reflect the SYSUT2 name used in $PDSLOAD for CNTL.
The allocation for the SYSEXEC needs to follow the shop standard for the
installation of REXX Execs.  Change the SYSUT2 to point to the library
where the Execs reside.  If this is not possible due to restrictions,
then utilize the following TSO command.  It can be stored as a PF key
command:

ALTLIB ACTIVATE APPLICATION(CLIST) DATASET ('FUSION.SYSEXEC')

Modify FUSION.SYSEXEC to the alternative SYSEXEC if it was modified.

Type TSO FUSION to start the utility.


Summary

FUSION was developed over a period of eight years.  It has evolved from
its initial form as a series of Eztrieve jobs to its current form as a
REXX/ISPF application.  I developed the tool as an aid to assist me and
my fellow associates with the task of applying new code releases to our
vendor-supplied and in-house written programs.  The tool is a
recognized production tool at West Bend Mutual and provides the change
management capability needed to manage our code changes on the
mainframe system.  A series of other tools that interact with FUSION
comprise the actual change management system.

Fusion will perform with a high degree of accuracy.  However, it is
important to compare the result file with the base file to avoid
potential file corruption.  As with any application, use Fusion at your
own risk and discretion.  Neither the author nor West Bend Mutual
Insurance Company assumes any liability from the use of Fusion.

Joseph Caughman is an applications program with 16 years experience
working with COBOL and Assembler on the MVS (now OS/390) system.  This
also includes CLIST, REXX and ISPF applications.  A graduate of the
University of South Carolina, he spent the first five years of his
career with Policy Management Systems Corporation (PMSC), a major
producer of insurance applications software.  He currently works for
the West Bend Mutual Insurance Company, in West Bend, WI. He can be
contacted via e-mail at jcaughman@wbmi.com or jcaughman@charter.net.



